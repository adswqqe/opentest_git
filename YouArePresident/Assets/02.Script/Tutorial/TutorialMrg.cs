using System.Collections;
using System.Collections.Generic;
using UnityEngine.UI;
using UnityEngine;

public class TutorialMrg : MonoBehaviour
{
    public static TutorialMrg Instance;
    
    public float typeSpeed;
    public string[] textLine;
    public Text theText;
    public TextAsset textFile;
    public GameObject textBox;
    public GameObject Report;
    public bool isSceneDone;
    public bool isBackMain;
    bool iswait = true;
    bool isTyping;
    bool cancelTyping;
    public int line = 0;

    // Use this for initialization
    void Awake ()
    {
        if (Instance == null)
            Instance = this;
        else if (Instance != this)
            Destroy(this.gameObject);

        if (textFile != null)
        {
            textLine = (textFile.text.Split('\n'));
        }

        StartCoroutine("Tutorial");
        Scrolling();

        DontDestroyOnLoad(this.gameObject);
    }

    public void DestroyAll()
    {
        SceneMrg.sceneMrg.NextScene(1);
        StartCoroutine("IDestroyAll");
    }

    public void OpenReport()
    {
        if (!TutorialMrg.Instance.textBox.activeSelf)
        {
            Report.SetActive(true);
            SoundMrg.Instance.StartEFF(5);
        }
    }

    void Scrolling()
    {
        StartCoroutine("ScrollText", textLine[line]);
        ++line;
    }

    IEnumerator IDestroyAll()
    {
        yield return new WaitForSeconds(1.0f);
        Destroy(TutorialCanvas.Instance.gameObject);
        Destroy(TutorialData.Instance.gameObject);
        Destroy(this.gameObject);

    }

    IEnumerator Tutorial()
    {
        while (true)
        {
            yield return null;

            if (Input.GetMouseButtonDown(0) && textBox.activeSelf)
            {
                if (isTyping)
                {
                    cancelTyping = true;
                }
                else if (line == 26)
                {
                    textBox.SetActive(false);
                    DataMrg.dataMrg.SaveTutorial();
                    DestroyAll();
                    break;
                }
                else
                {
                    Scrolling();
                }
            }

            if (isBackMain && iswait)
            {
                yield return new WaitForSeconds(1.5f);
                iswait = false;
            }   
            switch (line)
            {
                case 4:
                    textBox.SetActive(false);

                    if (TutorialUIMrg.Instance.letterHead.activeSelf)
                    {
                        textBox.SetActive(true);
                        Scrolling();
                    }
                        break;
                case 10:
                    textBox.SetActive(false);
                    if (!TutorialUIMrg.Instance.letterHead.activeSelf)
                    {
                        textBox.SetActive(true);
                        Scrolling();
                    }
                    break;

                case 13:
                    textBox.SetActive(false);

                    if(isSceneDone)
                    {
                        textBox.SetActive(true);
                        Scrolling();
                    }
                    break;

                case 18:
                    textBox.SetActive(false);
                    
                    if(isBackMain)
                    {
                        textBox.SetActive(true);
                        Scrolling();
                    }
                    break;

                case 19:
                    TutorialData.Instance.Day.text = "27";
                    TutorialData.Instance.Gold.text = "200";
                    break;

                case 21:
                    textBox.SetActive(false);

                    if(Report.active)
                    {
                        textBox.SetActive(true);
                        Scrolling();
                    }
                    break;
            }

        }
    }

    IEnumerator ScrollText(string lineOfText)
    {
        int letter = 0;
        theText.text = "";
        isTyping = true;
        cancelTyping = false;

        while (isTyping && !cancelTyping && letter < lineOfText.Length - 1)
        {
            theText.text += lineOfText[letter];
            letter += 1;
            yield return new WaitForSeconds(typeSpeed);
        }
        theText.text = lineOfText;
        isTyping = false;
        cancelTyping = false;
    }
}
